from __future__ import annotations

import os
import tempfile
from typing import Any, Dict, List, Optional

# Reuse the existing robust CLI runner and log parsing from the tuner
from solvermind.tuner.run.run_instance_cli import run_instance_cli as _run_instance_cli
from solvermind.tuner.utils.version_check import ensure_scip_version as _ensure_scip_version

_VERSION_CHECKED = False

def _ensure_version_once():
    global _VERSION_CHECKED
    if not _VERSION_CHECKED:
        _ensure_scip_version()
        _VERSION_CHECKED = True


def _write_set_file(path: str, params: Dict[str, Any], time_limit: float, seed: Optional[int]) -> None:
    with open(path, "w", encoding="utf-8") as f:
        f.write("# SCIP parameter set generated by SolverMind (shared runner)\n")
        for k, v in (params or {}).items():
            f.write(f"{k} = {v}\n")
        f.write(f"\nlimits/time = {float(time_limit)}\n")
        if seed is not None:
            try:
                f.write(f"randomization/randomseedshift = {int(seed)}\n")
            except Exception:
                pass


def run_instance(
    cfg: Dict[str, Any],
    instance_path: str,
    tau: float,
    *,
    outdir: Optional[str] = None,
    seed: Optional[int] = None,
    trial_id: Optional[int] = None,
    extra_commands: Optional[List[str]] = None,
) -> Dict[str, Any]:
    """Unified SCIP CLI execution for a single instance.

    - Accepts a dict `cfg` of parameter name -> value.
    - Writes a temporary .set file including the provided parameters and time/seed.
    - Invokes the shared CLI runner (stdin script) with that .set file.

    Returns a metrics dict including status, solve_time, bounds, nodes, and log_path.
    Also includes baseline-style aliases: time (== solve_time) and nodes (float).
    """
    # Prepare working directory
    work_root = outdir or os.getcwd()
    os.makedirs(work_root, exist_ok=True)

    with tempfile.TemporaryDirectory(dir=work_root) as td:
        _ensure_version_once()
        set_path = os.path.join(td, "params.set")
        _write_set_file(set_path, cfg or {}, time_limit=tau, seed=seed)

        # Use a per-instance subdir when outdir is a batch root; let underlying runner decide
        metrics = _run_instance_cli(
            instance_path=instance_path,
            settings_file=set_path,
            meta_applied={},
            time_limit=float(tau),
            outdir=work_root,
            seed=seed,
            trial_id=trial_id,
        )

        # Add baseline-friendly aliases
        m = dict(metrics)
        m.setdefault("time", float(m.get("solve_time", 0.0)))
        try:
            nn = m.get("n_nodes")
            m.setdefault("nodes", float(nn) if nn is not None else 0.0)
        except Exception:
            m.setdefault("nodes", 0.0)
        return m
